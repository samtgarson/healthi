function home() {
    $(".slider-nav ul").pep({
        axis: "x",
        velocityMultiplier: 0,
        removeMargins: !1,
        stop: dragStop,
        drag: dragDuring,
        cssEaseDuration: 300,
        cssEaseString: "easeOutExpo",
        useCSSTranslation: !1,
        shouldEase: !1,
        callIfNotStarted: []
    }), $(".slider-content").pep({
        axis: "x",
        velocityMultiplier: 0,
        removeMargins: !1,
        stop: pageDragStop,
        drag: pageDragDuring,
        cssEaseDuration: 300,
        cssEaseString: "easeOutExpo",
        useCSSTranslation: !1,
        shouldEase: !1,
        callIfNotStarted: []
    });
    var dragged = 0;
    $(".slider-nav li").on("touchstart mousedown", function() {
        dragged = 0, $(this).on("touchmove mousemove", function() {
            dragged = 1;
        });
    }).on("touchend mouseup", function() {
        dragged || slideAll($(this).index());
    });
}

function dragStop() {
    var navArray = [ 0, -79, -158, -237 ], navTarget = parseInt($(".selector ul").css("marginLeft")), navIndex = nearest(navTarget, navArray)[1];
    return slideAll(navIndex), !1;
}

function pageDragStop() {
    var pageArray = [ 0, -100, -200, -300 ], pageTarget = parseInt($(".slider-content").css("left")) / $(".slider-content").width(), pageIndex = nearest(400 * pageTarget, pageArray)[1];
    return slideAll(pageIndex), !1;
}

function dragDuring() {
    var l = parseInt($(".slider-nav ul").css("left")) - $("body").width() / 2;
    $(".selector ul").css("marginLeft", l - 2);
    var dragPercent = parseFloat($(".selector ul").css("margin-left")) / $(".slider-nav ul").width(), pageMargin = $(".slider-content").width() * dragPercent;
    $(".slider-content").css("left", pageMargin);
}

function pageDragDuring() {
    var bodyW = $("body").width() / 2, dragPercent = parseInt($(".slider-content").css("left")) / $(".slider-content").width(), selectMargin = dragPercent * $(".slider-nav ul").width(), navMargin = bodyW + selectMargin;
    $(".slider-nav ul").css("left", navMargin), $(".selector ul").css("marginLeft", selectMargin - 2);
}

function nearest(num, arr) {
    var i = 0, res = arr.reduce(function(prev, curr) {
        return Math.abs(curr - num) < Math.abs(prev - num) ? (i++, curr) : prev;
    });
    return [ res, i ];
}

function slideAll(index) {
    var r = -79 * index, m = $("body").width() / 2 + r, e = "easeOutExpo", time = 700, pageMargin = 100 * index;
    $(".slider-content").animate({
        left: "-" + pageMargin + "%"
    }, time, e), $(".selector ul").animate({
        marginLeft: r
    }, time, e), $(".slider-nav ul").animate({
        left: m
    }, time, e);
    var page = $(".slidee").eq(index).attr("class").split("slidee ")[1];
    changePage(page);
}

function pageReady() {
    this.$watch("name", loadContent);
}

function loadContent() {
    var file = "build/templates/" + this.name + ".html";
    $.get(file, function(html) {
        $("section.main").html(html);
    }), eval(this.name + "()");
}

function appReady() {
    this.$watch("title", this.changeTitle);
}

function closeMenu(newPage) {
    "undefined" == typeof newPage && (newPage = VM.name), this.menuOpen = !1, this.title = newPage;
}

function openMenu() {
    console.log("opened"), this.menuOpen = !0, this.title = "menu";
}

function changeTitle(page) {
    var n = "<span class='new'>" + page + "</span>";
    $("#title").prepend(n), setTimeout(function() {
        $(".new").css("margin-top", 0);
    }, 100), setTimeout(function() {
        $(".old").remove(), $(".new").removeClass("new").addClass("old");
    }, 500);
}

Vue.component("Page", {
    template: "hello",
    ready: pageReady,
    data: {
        name: "home"
    },
    methods: {
        loadContent: loadContent
    }
});

var app = new Vue({
    el: "body",
    ready: appReady,
    data: {
        title: "home",
        menuOpen: !1
    },
    methods: {
        toggleMenu: function() {
            this.menuOpen ? this.closeMenu() : this.openMenu();
        },
        closeMenu: closeMenu,
        changeTitle: changeTitle,
        openMenu: openMenu
    }
}), VM = app.$.pageref;

!function($, window, undefined) {
    "use strict";
    function Pep(el, options) {
        this.name = pluginName, this.el = el, this.$el = $(el), this.options = $.extend({}, defaults, options), 
        this.$document = $(this.$el[0].ownerDocument), this.$body = this.$document.find("body"), 
        this.moveTrigger = "MSPointerMove touchmove mousemove", this.startTrigger = "MSPointerDown touchstart mousedown", 
        this.stopTrigger = "MSPointerUp touchend mouseup", this.startTriggerArray = this.startTrigger.split(" "), 
        this.moveTriggerArray = this.moveTrigger.split(" "), this.stopTriggerArray = this.stopTrigger.split(" "), 
        this.stopEvents = [ this.stopTrigger, this.options.stopEvents ].join(" "), this.$container = "window" === this.options.constrainTo ? this.$document : this.options.constrainTo && "parent" !== this.options.constrainTo ? $(this.options.constrainTo) : this.$el.parent(), 
        this.isPointerEventCompatible() && this.applyMSDefaults(), this.CSSEaseHash = this.getCSSEaseHash(), 
        this.scale = 1, this.started = !1, this.disabled = !1, this.resetVelocityQueue(), 
        this.init();
    }
    var pluginName = "pep", defaults = {
        initiate: function() {},
        start: function() {},
        drag: function() {},
        stop: function() {},
        rest: function() {},
        moveTo: !1,
        callIfNotStarted: [ "stop", "rest" ],
        startThreshold: [ 0, 0 ],
        grid: [ 1, 1 ],
        debug: !1,
        activeClass: "pep-active",
        multiplier: 1,
        velocityMultiplier: 2.5,
        shouldPreventDefault: !0,
        allowDragEventPropagation: !0,
        stopEvents: "",
        hardwareAccelerate: !0,
        useCSSTranslation: !0,
        disableSelect: !0,
        cssEaseString: "cubic-bezier(0.190, 1.000, 0.220, 1.000)",
        cssEaseDuration: 1e3,
        shouldEase: !0,
        droppable: !1,
        droppableActiveClass: "pep-dpa",
        overlapFunction: !1,
        constrainTo: !1,
        removeMargins: !0,
        place: !0,
        deferPlacement: !1,
        axis: null,
        forceNonCSS3Movement: !1,
        elementsWithInteraction: "input",
        revert: !1,
        revertAfter: "stop",
        revertIf: function() {
            return !0;
        }
    };
    Pep.prototype.init = function() {
        this.options.debug && this.buildDebugDiv(), this.options.disableSelect && this.disableSelect(), 
        this.options.place && !this.options.deferPlacement && (this.positionParent(), this.placeObject()), 
        this.ev = {}, this.pos = {}, this.subscribe();
    }, Pep.prototype.subscribe = function() {
        var self = this;
        this.$el.on(this.startTrigger, function(ev) {
            self.handleStart(ev);
        }), this.$el.on(this.startTrigger, this.options.elementsWithInteraction, function(ev) {
            ev.stopPropagation();
        }), this.$document.on(this.stopEvents, function(ev) {
            self.handleStop(ev);
        }), this.$document.on(this.moveTrigger, function(ev) {
            self.moveEvent = ev;
        });
    }, Pep.prototype.handleStart = function(ev) {
        var self = this;
        if (this.isValidMoveEvent(ev) && !this.disabled) {
            this.isPointerEventCompatible() && ev.preventManipulation && ev.preventManipulation(), 
            ev = this.normalizeEvent(ev), this.options.place && this.options.deferPlacement && (this.positionParent(), 
            this.placeObject()), this.log({
                type: "event",
                event: ev.type
            }), this.options.hardwareAccelerate && !this.hardwareAccelerated && (this.hardwareAccelerate(), 
            this.hardwareAccelerated = !0);
            var shouldContinue = this.options.initiate.call(this, ev, this);
            if (shouldContinue === !1) return;
            clearTimeout(this.restTimeout), this.$el.addClass(this.options.activeClass), this.removeCSSEasing(), 
            this.startX = this.ev.x = ev.pep.x, this.startY = this.ev.y = ev.pep.y, this.initialPosition = this.initialPosition || this.$el.position(), 
            this.startEvent = this.moveEvent = ev, this.active = !0, this.options.shouldPreventDefault && ev.preventDefault(), 
            this.options.allowDragEventPropagation || ev.stopPropagation(), function watchMoveLoop() {
                self.active && (self.handleMove(), self.requestAnimationFrame(watchMoveLoop));
            }($, self);
        }
    }, Pep.prototype.handleMove = function() {
        if ("undefined" != typeof this.moveEvent) {
            var ev = this.normalizeEvent(this.moveEvent), curX = window.parseInt(ev.pep.x / this.options.grid[0]) * this.options.grid[0], curY = window.parseInt(ev.pep.y / this.options.grid[1]) * this.options.grid[1];
            this.addToLIFO({
                time: ev.timeStamp,
                x: curX,
                y: curY
            });
            var dx, dy;
            if ($.inArray(ev.type, this.startTriggerArray) > -1 ? (dx = 0, dy = 0) : (dx = curX - this.ev.x, 
            dy = curY - this.ev.y), this.dx = dx, this.dy = dy, this.ev.x = curX, this.ev.y = curY, 
            0 === dx && 0 === dy) return void this.log({
                type: "event",
                event: "** stopped **"
            });
            var initialDx = Math.abs(this.startX - curX), initialDy = Math.abs(this.startY - curY);
            !this.started && (initialDx > this.options.startThreshold[0] || initialDy > this.options.startThreshold[1]) && (this.started = !0, 
            this.$el.addClass("pep-start"), this.options.start.call(this, this.startEvent, this)), 
            this.options.droppable && this.calculateActiveDropRegions();
            var continueDrag = this.options.drag.call(this, ev, this);
            if (continueDrag === !1) return void this.resetVelocityQueue();
            this.log({
                type: "event",
                event: ev.type
            }), this.log({
                type: "event-coords",
                x: this.ev.x,
                y: this.ev.y
            }), this.log({
                type: "velocity"
            });
            var xOp, yOp, hash = this.handleConstraint(dx, dy);
            "function" == typeof this.options.moveTo ? (xOp = dx >= 0 ? "+=" + Math.abs(dx / this.scale) * this.options.multiplier : "-=" + Math.abs(dx / this.scale) * this.options.multiplier, 
            yOp = dy >= 0 ? "+=" + Math.abs(dy / this.scale) * this.options.multiplier : "-=" + Math.abs(dy / this.scale) * this.options.multiplier, 
            this.options.constrainTo && (xOp = hash.x !== !1 ? hash.x : xOp, yOp = hash.y !== !1 ? hash.y : yOp), 
            "x" === this.options.axis && (yOp = hash.y), "y" === this.options.axis && (xOp = hash.x), 
            this.options.moveTo.call(this, xOp, yOp)) : this.shouldUseCSSTranslation() ? (dx = dx / this.scale * this.options.multiplier, 
            dy = dy / this.scale * this.options.multiplier, this.options.constrainTo && (dx = hash.x === !1 ? dx : 0, 
            dy = hash.y === !1 ? dy : 0), "x" === this.options.axis && (dy = 0), "y" === this.options.axis && (dx = 0), 
            this.moveToUsingTransforms(dx, dy)) : (xOp = dx >= 0 ? "+=" + Math.abs(dx / this.scale) * this.options.multiplier : "-=" + Math.abs(dx / this.scale) * this.options.multiplier, 
            yOp = dy >= 0 ? "+=" + Math.abs(dy / this.scale) * this.options.multiplier : "-=" + Math.abs(dy / this.scale) * this.options.multiplier, 
            this.options.constrainTo && (xOp = hash.x !== !1 ? hash.x : xOp, yOp = hash.y !== !1 ? hash.y : yOp), 
            "x" === this.options.axis && (yOp = hash.y), "y" === this.options.axis && (xOp = hash.x), 
            this.moveTo(xOp, yOp));
        }
    }, Pep.prototype.handleStop = function(ev) {
        this.active && (this.log({
            type: "event",
            event: ev.type
        }), this.active = !1, this.$el.removeClass("pep-start").addClass("pep-ease"), this.options.droppable && this.calculateActiveDropRegions(), 
        (this.started || !this.started && $.inArray("stop", this.options.callIfNotStarted) > -1) && this.options.stop.call(this, ev, this), 
        this.options.shouldEase ? this.ease(ev, this.started) : this.removeActiveClass(), 
        this.options.revert && ("stop" === this.options.revertAfter || !this.options.shouldEase) && this.options.revertIf && this.options.revertIf() && this.revert(), 
        this.started = !1, this.resetVelocityQueue());
    }, Pep.prototype.ease = function(ev, started) {
        var vel = (this.$el.position(), this.velocity()), x = (this.dt, vel.x / this.scale * this.options.multiplier), y = vel.y / this.scale * this.options.multiplier, hash = this.handleConstraint(x, y, !0);
        this.cssAnimationsSupported() && this.$el.css(this.getCSSEaseHash());
        var xOp = vel.x > 0 ? "+=" + x : "-=" + Math.abs(x), yOp = vel.y > 0 ? "+=" + y : "-=" + Math.abs(y);
        this.options.constrainTo && (xOp = hash.x !== !1 ? hash.x : xOp, yOp = hash.y !== !1 ? hash.y : yOp), 
        "x" === this.options.axis && (yOp = "+=0"), "y" === this.options.axis && (xOp = "+=0");
        var jsAnimateFallback = !this.cssAnimationsSupported() || this.options.forceNonCSS3Movement;
        "function" == typeof this.options.moveTo ? this.options.moveTo.call(this, xOp, yOp) : this.moveTo(xOp, yOp, jsAnimateFallback);
        var self = this;
        this.restTimeout = setTimeout(function() {
            self.options.droppable && self.calculateActiveDropRegions(), (started || !started && $.inArray("rest", self.options.callIfNotStarted) > -1) && self.options.rest.call(self, ev, self), 
            self.options.revert && "ease" === self.options.revertAfter && self.options.shouldEase && self.options.revertIf && self.options.revertIf() && self.revert(), 
            self.removeActiveClass();
        }, this.options.cssEaseDuration);
    }, Pep.prototype.normalizeEvent = function(ev) {
        return ev.pep = {}, this.isPointerEventCompatible() || !this.isTouch(ev) ? (ev.pageX ? (ev.pep.x = ev.pageX, 
        ev.pep.y = ev.pageY) : (ev.pep.x = ev.originalEvent.pageX, ev.pep.y = ev.originalEvent.pageY), 
        ev.pep.type = ev.type) : (ev.pep.x = ev.originalEvent.touches[0].pageX, ev.pep.y = ev.originalEvent.touches[0].pageY, 
        ev.pep.type = ev.type), ev;
    }, Pep.prototype.resetVelocityQueue = function() {
        this.velocityQueue = new Array(5);
    }, Pep.prototype.moveTo = function(x, y, animate) {
        this.log({
            type: "delta",
            x: x,
            y: y
        }), animate ? this.$el.animate({
            top: y,
            left: x
        }, this.options.cssEaseDuration / 2, "easeOutQuad", {
            queue: !1
        }) : this.$el.stop(!0, !1).css({
            top: y,
            left: x
        });
    }, Pep.prototype.moveToUsingTransforms = function(x, y) {
        var matrixArray = this.matrixToArray(this.matrixString());
        this.cssX || (this.cssX = this.xTranslation(matrixArray)), this.cssY || (this.cssY = this.yTranslation(matrixArray)), 
        this.cssX = this.cssX + x, this.cssY = this.cssY + y, this.log({
            type: "delta",
            x: x,
            y: y
        }), matrixArray[4] = this.cssX, matrixArray[5] = this.cssY, this.translation = this.arrayToMatrix(matrixArray), 
        this.transform(this.translation);
    }, Pep.prototype.transform = function(value) {
        this.$el.css({
            "-webkit-transform": value,
            "-moz-transform": value,
            "-ms-transform": value,
            "-o-transform": value,
            transform: value
        });
    }, Pep.prototype.xTranslation = function(matrixArray) {
        return matrixArray = matrixArray || this.matrixToArray(this.matrixString()), parseInt(matrixArray[4], 10);
    }, Pep.prototype.yTranslation = function(matrixArray) {
        return matrixArray = matrixArray || this.matrixToArray(this.matrixString()), parseInt(matrixArray[5], 10);
    }, Pep.prototype.matrixString = function() {
        var validMatrix = function(o) {
            return !(!o || "none" === o || o.indexOf("matrix") < 0);
        }, matrix = "matrix(1, 0, 0, 1, 0, 0)";
        return validMatrix(this.$el.css("-webkit-transform")) && (matrix = this.$el.css("-webkit-transform")), 
        validMatrix(this.$el.css("-moz-transform")) && (matrix = this.$el.css("-moz-transform")), 
        validMatrix(this.$el.css("-ms-transform")) && (matrix = this.$el.css("-ms-transform")), 
        validMatrix(this.$el.css("-o-transform")) && (matrix = this.$el.css("-o-transform")), 
        validMatrix(this.$el.css("transform")) && (matrix = this.$el.css("transform")), 
        matrix;
    }, Pep.prototype.matrixToArray = function(str) {
        return str.split("(")[1].split(")")[0].split(",");
    }, Pep.prototype.arrayToMatrix = function(array) {
        return "matrix(" + array.join(",") + ")";
    }, Pep.prototype.addToLIFO = function(val) {
        var arr = this.velocityQueue;
        arr = arr.slice(1, arr.length), arr.push(val), this.velocityQueue = arr;
    }, Pep.prototype.velocity = function() {
        for (var sumX = 0, sumY = 0, i = 0; i < this.velocityQueue.length - 1; i++) this.velocityQueue[i] && (sumX += this.velocityQueue[i + 1].x - this.velocityQueue[i].x, 
        sumY += this.velocityQueue[i + 1].y - this.velocityQueue[i].y, this.dt = this.velocityQueue[i + 1].time - this.velocityQueue[i].time);
        return {
            x: sumX * this.options.velocityMultiplier,
            y: sumY * this.options.velocityMultiplier
        };
    }, Pep.prototype.revert = function() {
        this.shouldUseCSSTranslation() && this.moveToUsingTransforms(-this.xTranslation(), -this.yTranslation()), 
        this.moveTo(this.initialPosition.left, this.initialPosition.top);
    }, Pep.prototype.requestAnimationFrame = function(callback) {
        return window.requestAnimationFrame && window.requestAnimationFrame(callback) || window.webkitRequestAnimationFrame && window.webkitRequestAnimationFrame(callback) || window.mozRequestAnimationFrame && window.mozRequestAnimationFrame(callback) || window.oRequestAnimationFrame && window.mozRequestAnimationFrame(callback) || window.msRequestAnimationFrame && window.msRequestAnimationFrame(callback) || window.setTimeout(callback, 1e3 / 60);
    }, Pep.prototype.positionParent = function() {
        this.options.constrainTo && !this.parentPositioned && (this.parentPositioned = !0, 
        "parent" === this.options.constrainTo ? this.$container.css({
            position: "relative"
        }) : "window" === this.options.constrainTo && "#document" !== this.$container.get(0).nodeName && "static" !== this.$container.css("position") && this.$container.css({
            position: "static"
        }));
    }, Pep.prototype.placeObject = function() {
        this.objectPlaced || (this.objectPlaced = !0, this.offset = "parent" === this.options.constrainTo || this.hasNonBodyRelative() ? this.$el.position() : this.$el.offset(), 
        parseInt(this.$el.css("left"), 10) && (this.offset.left = this.$el.css("left")), 
        parseInt(this.$el.css("top"), 10) && (this.offset.top = this.$el.css("top")), this.options.removeMargins && this.$el.css({
            margin: 0
        }), this.$el.css({
            position: "absolute",
            top: this.offset.top,
            left: this.offset.left
        }));
    }, Pep.prototype.hasNonBodyRelative = function() {
        return this.$el.parents().filter(function() {
            var $this = $(this);
            return $this.is("body") || "relative" === $this.css("position");
        }).length > 1;
    }, Pep.prototype.setScale = function(val) {
        this.scale = val;
    }, Pep.prototype.setMultiplier = function(val) {
        this.options.multiplier = val;
    }, Pep.prototype.removeCSSEasing = function() {
        this.cssAnimationsSupported() && this.$el.css(this.getCSSEaseHash(!0));
    }, Pep.prototype.disableSelect = function() {
        this.$el.css({
            "-webkit-touch-callout": "none",
            "-webkit-user-select": "none",
            "-khtml-user-select": "none",
            "-moz-user-select": "none",
            "-ms-user-select": "none",
            "user-select": "none"
        });
    }, Pep.prototype.removeActiveClass = function() {
        this.$el.removeClass([ this.options.activeClass, "pep-ease" ].join(" "));
    }, Pep.prototype.handleConstraint = function(dx, dy, accountForTranslation) {
        var pos = this.$el.position();
        this.pos.x = pos.left, this.pos.y = pos.top;
        var upperYLimit, upperXLimit, lowerXLimit, lowerYLimit, hash = {
            x: !1,
            y: !1
        };
        return this.log({
            type: "pos-coords",
            x: this.pos.x,
            y: this.pos.y
        }), $.isArray(this.options.constrainTo) ? (this.options.constrainTo[3] !== undefined && this.options.constrainTo[1] !== undefined && (upperXLimit = this.options.constrainTo[1] === !1 ? 1/0 : this.options.constrainTo[1], 
        lowerXLimit = this.options.constrainTo[3] === !1 ? -1/0 : this.options.constrainTo[3]), 
        this.options.constrainTo[0] !== !1 && this.options.constrainTo[2] !== !1 && (upperYLimit = this.options.constrainTo[2] === !1 ? 1/0 : this.options.constrainTo[2], 
        lowerYLimit = this.options.constrainTo[0] === !1 ? -1/0 : this.options.constrainTo[0]), 
        this.pos.x + dx < lowerXLimit && (hash.x = lowerXLimit), this.pos.y + dy < lowerYLimit && (hash.y = lowerYLimit)) : "string" == typeof this.options.constrainTo && (lowerXLimit = 0, 
        lowerYLimit = 0, upperXLimit = this.$container.width() - this.$el.outerWidth(), 
        upperYLimit = this.$container.height() - this.$el.outerHeight(), this.pos.x + dx < 0 && (hash.x = 0), 
        this.pos.y + dy < 0 && (hash.y = 0)), this.pos.x + dx > upperXLimit && (hash.x = upperXLimit), 
        this.pos.y + dy > upperYLimit && (hash.y = upperYLimit), this.shouldUseCSSTranslation() && accountForTranslation && (hash.x === lowerXLimit && this.xTranslation() && (hash.x = lowerXLimit - this.xTranslation()), 
        hash.x === upperXLimit && this.xTranslation() && (hash.x = upperXLimit - this.xTranslation()), 
        hash.y === lowerYLimit && this.yTranslation() && (hash.y = lowerYLimit - this.yTranslation()), 
        hash.y === upperYLimit && this.yTranslation() && (hash.y = upperYLimit - this.yTranslation())), 
        hash;
    }, Pep.prototype.getCSSEaseHash = function(reset) {
        "undefined" == typeof reset && (reset = !1);
        var cssEaseString;
        if (reset) cssEaseString = ""; else {
            if (this.CSSEaseHash) return this.CSSEaseHash;
            cssEaseString = [ "all", this.options.cssEaseDuration + "ms", this.options.cssEaseString ].join(" ");
        }
        return {
            "-webkit-transition": cssEaseString,
            "-moz-transition": cssEaseString,
            "-ms-transition": cssEaseString,
            "-o-transition": cssEaseString,
            transition: cssEaseString
        };
    }, Pep.prototype.calculateActiveDropRegions = function() {
        var self = this;
        this.activeDropRegions = [], $.each($(this.options.droppable), function(idx, el) {
            var $el = $(el);
            self.isOverlapping($el, self.$el) ? ($el.addClass(self.options.droppableActiveClass), 
            self.activeDropRegions.push($el)) : $el.removeClass(self.options.droppableActiveClass);
        });
    }, Pep.prototype.isOverlapping = function($a, $b) {
        if (this.options.overlapFunction) return this.options.overlapFunction($a, $b);
        var rect1 = $a[0].getBoundingClientRect(), rect2 = $b[0].getBoundingClientRect();
        return !(rect1.right < rect2.left || rect1.left > rect2.right || rect1.bottom < rect2.top || rect1.top > rect2.bottom);
    }, Pep.prototype.isTouch = function(ev) {
        return ev.type.search("touch") > -1;
    }, Pep.prototype.isPointerEventCompatible = function() {
        return "MSPointerEvent" in window;
    }, Pep.prototype.applyMSDefaults = function() {
        this.$el.css({
            "-ms-touch-action": "none",
            "touch-action": "none",
            "-ms-scroll-chaining": "none",
            "-ms-scroll-limit": "0 0 0 0"
        });
    }, Pep.prototype.isValidMoveEvent = function(ev) {
        return !this.isTouch(ev) || this.isTouch(ev) && ev.originalEvent.touches && 1 === ev.originalEvent.touches.length;
    }, Pep.prototype.shouldUseCSSTranslation = function() {
        if ("undefined" != typeof this.useCSSTranslation) return this.useCSSTranslation;
        var useCSSTranslation = !1;
        return useCSSTranslation = !this.options.useCSSTranslation || "undefined" != typeof Modernizr && !Modernizr.csstransforms ? !1 : !0, 
        this.useCSSTranslation = useCSSTranslation, useCSSTranslation;
    }, Pep.prototype.cssAnimationsSupported = function() {
        if ("undefined" != typeof this.cssAnimationsSupport) return this.cssAnimationsSupport;
        if ("undefined" != typeof Modernizr && Modernizr.cssanimations) return this.cssAnimationsSupport = !0, 
        !0;
        var animation = !1, elm = document.createElement("div"), animationstring = "animation", keyframeprefix = "", domPrefixes = "Webkit Moz O ms Khtml".split(" "), pfx = "";
        if (elm.style.animationName && (animation = !0), animation === !1) for (var i = 0; i < domPrefixes.length; i++) if (elm.style[domPrefixes[i] + "AnimationName"] !== undefined) {
            pfx = domPrefixes[i], animationstring = pfx + "Animation", keyframeprefix = "-" + pfx.toLowerCase() + "-", 
            animation = !0;
            break;
        }
        return this.cssAnimationsSupport = animation, animation;
    }, Pep.prototype.hardwareAccelerate = function() {
        this.$el.css({
            "-webkit-perspective": 1e3,
            perspective: 1e3,
            "-webkit-backface-visibility": "hidden",
            "backface-visibility": "hidden"
        });
    }, Pep.prototype.getMovementValues = function() {
        return {
            ev: this.ev,
            pos: this.pos,
            velocity: this.velocity()
        };
    }, Pep.prototype.buildDebugDiv = function() {
        var $debugDiv;
        0 === $("#pep-debug").length && ($debugDiv = $("<div></div>"), $debugDiv.attr("id", "pep-debug").append("<div style='font-weight:bold; background: red; color: white;'>DEBUG MODE</div>").append("<div id='pep-debug-event'>no event</div>").append("<div id='pep-debug-ev-coords'>event coords: <span class='pep-x'>-</span>, <span class='pep-y'>-</span></div>").append("<div id='pep-debug-pos-coords'>position coords: <span class='pep-x'>-</span>, <span class='pep-y'>-</span></div>").append("<div id='pep-debug-velocity'>velocity: <span class='pep-x'>-</span>, <span class='pep-y'>-</span></div>").append("<div id='pep-debug-delta'>&Delta; movement: <span class='pep-x'>-</span>, <span class='pep-y'>-</span></div>").css({
            position: "fixed",
            bottom: 5,
            right: 5,
            zIndex: 99999,
            textAlign: "right",
            fontFamily: "Arial, sans",
            fontSize: 10,
            border: "1px solid #DDD",
            padding: "3px",
            background: "white",
            color: "#333"
        }));
        var self = this;
        setTimeout(function() {
            self.debugElements = {
                $event: $("#pep-debug-event"),
                $velocityX: $("#pep-debug-velocity .pep-x"),
                $velocityY: $("#pep-debug-velocity .pep-y"),
                $dX: $("#pep-debug-delta .pep-x"),
                $dY: $("#pep-debug-delta .pep-y"),
                $evCoordsX: $("#pep-debug-ev-coords .pep-x"),
                $evCoordsY: $("#pep-debug-ev-coords .pep-y"),
                $posCoordsX: $("#pep-debug-pos-coords .pep-x"),
                $posCoordsY: $("#pep-debug-pos-coords .pep-y")
            };
        }, 0), $("body").append($debugDiv);
    }, Pep.prototype.log = function(opts) {
        if (this.options.debug) switch (opts.type) {
          case "event":
            this.debugElements.$event.text(opts.event);
            break;

          case "pos-coords":
            this.debugElements.$posCoordsX.text(opts.x), this.debugElements.$posCoordsY.text(opts.y);
            break;

          case "event-coords":
            this.debugElements.$evCoordsX.text(opts.x), this.debugElements.$evCoordsY.text(opts.y);
            break;

          case "delta":
            this.debugElements.$dX.text(opts.x), this.debugElements.$dY.text(opts.y);
            break;

          case "velocity":
            var vel = this.velocity();
            this.debugElements.$velocityX.text(Math.round(vel.x)), this.debugElements.$velocityY.text(Math.round(vel.y));
        }
    }, Pep.prototype.toggle = function(on) {
        this.disabled = "undefined" == typeof on ? !this.disabled : !on;
    }, $.extend($.easing, {
        easeOutQuad: function(x, t, b, c, d) {
            return -c * (t /= d) * (t - 2) + b;
        },
        easeOutCirc: function(x, t, b, c, d) {
            return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
        },
        easeOutExpo: function(x, t, b, c, d) {
            return t === d ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
        }
    }), $.fn[pluginName] = function(options) {
        return this.each(function() {
            if (!$.data(this, "plugin_" + pluginName)) {
                var pepObj = new Pep(this, options);
                $.data(this, "plugin_" + pluginName, pepObj), $.pep.peps.push(pepObj);
            }
        });
    }, $.pep = {}, $.pep.peps = [], $.pep.toggleAll = function(on) {
        $.each(this.peps, function(index, pepObj) {
            pepObj.toggle(on);
        });
    }, $.pep.unbind = function($obj) {
        var pep = $obj.data("plugin_" + pluginName);
        "undefined" != typeof pep && (pep.toggle(!1), $obj.removeData("plugin_" + pluginName));
    };
}(jQuery, window);